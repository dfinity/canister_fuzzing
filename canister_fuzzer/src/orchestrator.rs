//! This module orchestrates the fuzzing process using the `libafl` fuzzing framework.
//!
//! It defines the `FuzzerOrchestrator` trait, which provides a generic interface
//! for setting up and running fuzz tests against IC canisters. The main `run` function
//! configures and starts the `libafl` fuzzing loop, while the `test_one_input` function
//! provides a convenient way to debug specific inputs.

use chrono::Local;
use ic_state_machine_tests::StateMachine;
use ic_types::CanisterId;
use std::fs::{self, File};
use std::io::Read;
use std::path::PathBuf;
use std::sync::Arc;

use libafl::{
    corpus::inmemory_ondisk::InMemoryOnDiskCorpus,
    events::SimpleEventManager,
    executors::{inprocess::InProcessExecutor, ExitKind},
    feedbacks::{map::AflMapFeedback, CrashFeedback},
    fuzzer::{Fuzzer, StdFuzzer},
    inputs::BytesInput,
    mutators::{havoc_mutations, HavocScheduledMutator},
    observers::map::{hitcount_map::HitcountsMapObserver, StdMapObserver},
    schedulers::QueueScheduler,
    stages::{mutational::StdMutationalStage, AflStatsStage, CalibrationStage},
    state::StdState,
    Evaluator,
};

use ic_state_machine_tests::WasmResult;
use libafl::monitors::SimpleMonitor;
// use libafl::monitors::tui::{ui::TuiUI, TuiMonitor};
use libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list};

use crate::constants::{AFL_COVERAGE_MAP_SIZE, COVERAGE_FN_EXPORT_NAME};
use crate::fuzzer::FuzzerState;

/// A global, mutable static array to hold the coverage map.
///
/// # Safety
///
/// This is a raw pointer to a mutable static memory region, which is inherently `unsafe`.
/// It is used as a shared memory region between the fuzzer and the instrumented canister.
/// The `libafl` framework is designed to work with such a mechanism, which is a highly
/// optimized approach for coverage-guided fuzzing, inspired by AFL.
/// Access to this map is carefully controlled within the fuzzing loop.
static mut COVERAGE_MAP: &mut [u8] = &mut [0; AFL_COVERAGE_MAP_SIZE as usize];

/// A trait that defines the necessary components for a canister fuzzing target.
///
/// Implementors of this trait provide the specific logic for setting up the environment,
/// executing a test case against one or more canisters, and cleaning up afterwards.
pub trait FuzzerOrchestrator {
    /// Returns the name of the specific directory for this fuzzer.
    fn get_fuzzer_dir(&self) -> String;

    /// Returns a thread-safe reference to the IC `StateMachine`.
    fn get_state_machine(&self) -> Arc<StateMachine>;

    /// Returns the `CanisterId` of the canister that has been instrumented for coverage.
    fn get_coverage_canister_id(&self) -> CanisterId;

    /// Performs one-time initialization at the start of the fuzzing campaign.
    /// This is where canisters are typically installed.
    fn init(&mut self);

    /// Sets up the environment before each execution of a test case.
    /// This could involve resetting canister state to a clean snapshot.
    fn setup(&self);

    /// Executes a single fuzzing input against the target canister(s).
    ///
    /// # Arguments
    ///
    /// * `input` - The `BytesInput` generated by the fuzzer.
    ///
    /// # Returns
    ///
    /// * `ExitKind` - Indicates the outcome of the execution (e.g., `Ok`, `Crash`).
    fn execute(&self, input: BytesInput) -> ExitKind;

    /// Cleans up the environment after each execution.
    /// This could involve restoring the `StateMachine` from a snapshot.
    fn cleanup(&self);

    /// Creates and returns the path to the directory for storing new and interesting inputs.
    ///
    /// The directory is structured as `target/artifacts/<fuzzer_dir>/<timestamp>/input`.
    fn input_dir(&self) -> PathBuf {
        let input_dir = FuzzerState::get_target_dir()
            .join("artifacts")
            .join(self.get_fuzzer_dir().clone())
            .join(Local::now().format("%Y%m%d_%H%M").to_string())
            .join("input");
        fs::create_dir_all(&input_dir)
            .unwrap_or_else(|e| panic!("Failed to create input directory {input_dir:?}: {e}"));
        input_dir
    }

    /// Creates and returns the path to the directory for storing crashing inputs.
    ///
    /// The directory is structured as `target/artifacts/<fuzzer_dir>/<timestamp>/crashes`.
    fn crashes_dir(&self) -> PathBuf {
        let crashes_dir = FuzzerState::get_target_dir()
            .join("artifacts")
            .join(self.get_fuzzer_dir().clone())
            .join(Local::now().format("%Y%m%d_%H%M").to_string())
            .join("crashes");
        fs::create_dir_all(&crashes_dir)
            .unwrap_or_else(|e| panic!("Failed to create crashes directory {crashes_dir:?}: {e}"));
        crashes_dir
    }

    /// Returns the path to the seed corpus directory.
    ///
    /// This directory should contain initial valid inputs to kickstart the fuzzing process.
    /// It is structured as <fuzzer_dir>/corpus
    fn corpus_dir(&self) -> PathBuf {
        FuzzerState::get_target_dir()
            .parent()
            .unwrap()
            .join(self.get_fuzzer_dir().clone())
            .join("corpus")
    }

    /// Fetches the coverage map from the instrumented canister and updates the global `COVERAGE_MAP`.
    /// It does this by making a query call to the `export_coverage` function.
    #[allow(static_mut_refs)]
    fn set_coverage_map(&self) {
        let test = self.get_state_machine();
        let result = test.query(
            self.get_coverage_canister_id(),
            COVERAGE_FN_EXPORT_NAME,
            vec![],
        );
        if let Ok(WasmResult::Reply(result)) = result {
            unsafe { COVERAGE_MAP.copy_from_slice(&result) };
        }
    }

    /// Provides a mutable reference to the static `COVERAGE_MAP`.
    fn get_coverage_map(&self) -> &'static mut [u8] {
        unsafe { COVERAGE_MAP }
    }
}

/// The main entry point for running a fuzzing campaign.
///
/// This function sets up the `libafl` environment, including the executor,
/// state, feedbacks, and mutators. It then loads the initial corpus and
/// starts the fuzzing loop.
///
/// # Arguments
///
/// * `orchestrator` - An implementation of the `FuzzerOrchestrator` trait that defines the fuzzing target.
pub fn run<T>(mut orchestrator: T)
where
    T: FuzzerOrchestrator,
{
    orchestrator.init();

    // The harness is a closure that `libafl` will call for each fuzzed input.
    let mut harness = |input: &BytesInput| {
        orchestrator.setup();
        let result = orchestrator.execute(input.clone());
        orchestrator.set_coverage_map();
        orchestrator.cleanup();
        result
    };

    let hitcount_map_observer = HitcountsMapObserver::new(unsafe {
        StdMapObserver::new("coverage_map", orchestrator.get_coverage_map())
    });

    // Feedback mechanisms tell the fuzzer if an input is "interesting"
    let afl_map_feedback = AflMapFeedback::new(&hitcount_map_observer);
    let mut feedback = afl_map_feedback;
    let calibration_stage = CalibrationStage::new(&feedback);
    // The objective is to find crashes
    let mut objective = CrashFeedback::new();

    // A stats stage to print statistics about the fuzzing run.
    let stats_stage = AflStatsStage::builder()
        .map_observer(&hitcount_map_observer)
        .build()
        .unwrap();

    let mut state = StdState::new(
        StdRand::with_seed(current_nanos()),
        InMemoryOnDiskCorpus::new(orchestrator.input_dir()).unwrap(),
        InMemoryOnDiskCorpus::no_meta(orchestrator.crashes_dir()).unwrap(),
        &mut feedback,
        &mut objective,
    )
    .unwrap();

    let mon = SimpleMonitor::new(|s| println!("{s}"));
    // A TUI monitor can be used for a more sophisticated display.
    // Example:
    // let ui = TuiUI::with_version(String::from("My Fuzzer"), String::from("0.1.0"), false);
    // let mon = TuiMonitor::new(ui);
    let mut mgr = SimpleEventManager::new(mon);
    let scheduler = QueueScheduler::new();
    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);

    let mut executor = InProcessExecutor::new(
        &mut harness,
        tuple_list!(hitcount_map_observer),
        &mut fuzzer,
        &mut state,
        &mut mgr,
    )
    .expect("Failed to create the Executor");

    // Load initial inputs from the corpus directory
    let paths = fs::read_dir(orchestrator.corpus_dir()).unwrap();
    for path in paths {
        let p = path.unwrap().path();
        let mut f = File::open(p.clone()).unwrap();
        let mut buffer = Vec::new();
        f.read_to_end(&mut buffer).unwrap();
        fuzzer
            .evaluate_input(
                &mut state,
                &mut executor,
                &mut mgr,
                &BytesInput::new(buffer),
            )
            .unwrap();
    }
    // Standard mutational stage with a havoc mutator
    let mutator = HavocScheduledMutator::new(havoc_mutations());
    let mut stages = tuple_list!(
        calibration_stage,
        StdMutationalStage::new(mutator),
        stats_stage
    );

    // Start the fuzzing loop!
    fuzzer
        .fuzz_loop(&mut stages, &mut executor, &mut state, &mut mgr)
        .expect("Error in the fuzzing loop");
}

/// Executes a single input against the orchestrator's harness.
///
/// This function is useful for debugging specific inputs, such as those that
/// have caused a crash, without running the full fuzzing loop.
///
/// # Arguments
///
/// * `orchestrator` - An implementation of the `FuzzerOrchestrator` trait.
/// * `bytes` - The raw byte vector of the input to be tested.
pub fn test_one_input<T>(mut orchestrator: T, bytes: Vec<u8>)
where
    T: FuzzerOrchestrator,
{
    orchestrator.init();
    orchestrator.setup();
    let result = orchestrator.execute(BytesInput::new(bytes));
    orchestrator.cleanup();
    println!("Execution result: {result:?}");
}
